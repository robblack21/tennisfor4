<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tennis for 4 - MediaPipe Edition</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #22b14c, #00a2e8);
    }
    
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }
    
    .game-hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: auto;
    }
    
    .score-display {
      background: rgba(0,0,0,0.6);
      padding: 15px;
      border-radius: 10px;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .controls-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      pointer-events: auto;
      max-width: 300px;
    }
    
    .video-container {
      width: 100%;
      height: 150px;
      background: #333;
      border-radius: 5px;
      margin: 10px 0;
      position: relative;
    }
    
    video {
      width: 100%;
      height: 100%;
      border-radius: 5px;
    }
    
    button {
      background: #ff7f27;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      margin: 3px;
      font-weight: bold;
      font-size: 12px;
    }
    
    button:hover {
      background: #ff9966;
    }
    
    .status {
      padding: 5px;
      margin: 3px 0;
      border-radius: 3px;
      font-size: 12px;
    }
    
    .status.good { background: rgba(0,255,0,0.2); }
    .status.warn { background: rgba(255,255,0,0.2); }
    .status.error { background: rgba(255,0,0,0.2); }
    
    .pose-data {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 5px;
      margin: 5px 0;
      font-size: 10px;
    }
    
    .player-indicators {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    
    .player-indicator {
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      text-align: center;
    }
    
    .player-indicator.active {
      background: rgba(255,127,39,0.8);
    }
  </style>
</head>
<body>
  <div class="ui-overlay">
    <!-- Game HUD -->
    <div class="game-hud">
      <div class="score-display">
        <div>Player 1: <span id="team1-score">0</span> | Player 2: <span id="team2-score">0</span></div>
        <div>Game Status: <span id="game-status">Waiting for players</span></div>
      </div>
    </div>
    
    <!-- MediaPipe Controls -->
    <div class="controls-panel">
      <h3>üéæ MediaPipe Tennis</h3>
      
      <div style="display: flex; flex-wrap: wrap;">
        <button onclick="startCamera()">Start Camera</button>
        <button onclick="togglePoseTracking()">Toggle Pose</button>
        <button onclick="joinDailyRoom()">Join Multiplayer</button>
        <button onclick="resetGame()">Reset Game</button>
        <button onclick="toggleFullscreen()">Fullscreen</button>
      </div>
      
      <!-- Daily.js Video Call Interface -->
      <div id="daily-container" style="display: none;">
        <div style="margin: 10px 0; font-size: 12px; color: #ccc;">
          Multiplayer Video Call:
        </div>
        <iframe
          id="daily-iframe"
          width="100%"
          height="200"
          style="border-radius: 8px; border: none;"
          allow="camera; microphone; fullscreen; display-capture; autoplay">
        </iframe>
      </div>
      
      <!-- MediaPipe Camera (for pose tracking) -->
      <div class="video-container">
        <div style="font-size: 11px; color: #ccc; margin-bottom: 5px;">
          Pose Tracking Camera:
        </div>
        <video id="webcam" autoplay muted playsinline></video>
      </div>
      
      <div id="status-container">
        <div class="status" id="camera-status">Camera: Not started</div>
        <div class="status" id="mediapipe-status">MediaPipe: Loading...</div>
        <div class="status" id="daily-status">Daily: Not connected</div>
        <div class="status" id="game-status-detail">Game: Ready</div>
      </div>
      
      <div class="pose-data">
        <strong>Pose Data:</strong><br>
        Swing: <span id="swing-velocity">-</span><br>
        Ball: <span id="ball-position">-</span><br>
        Players: <span id="player-count">2</span>
      </div>
    </div>
    
    <!-- Player Indicators -->
    <div class="player-indicators">
      <div class="player-indicator active">Player 1</div>
      <div class="player-indicator">Player 2</div>
    </div>
  </div>

  <!-- Load Three.js and GLTFLoader -->
  <script src="lib/three.min.js"></script>
  <script src="lib/GLTFLoader.js"></script>
  
  <!-- Load Daily.js -->
  <script crossorigin src="https://unpkg.com/@daily-co/daily-js@0.64.0/dist/daily-iframe.js"></script>
  
  <!-- Load MediaPipe -->
  <script type="module">
    try {
      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js');
      window.TasksVision = vision;
      console.log('MediaPipe loaded successfully');
      updateStatus('mediapipe-status', 'MediaPipe: Ready ‚úÖ', 'good');
    } catch (error) {
      console.warn('MediaPipe not available:', error);
      updateStatus('mediapipe-status', 'MediaPipe: Failed ‚ùå', 'error');
    }
  </script>
  
  <script>
    // Global variables
    let scene, camera, renderer;
    let tennisCourtMesh, tennisBall;
    let players = [];
    let poseLandmarker;
    let webcamRunning = false;
    let poseTrackingActive = false;
    let currentPose = null;
    let lastSwingTime = 0;
    let cameraTime = 0; // For cinematic camera movement
    let baseCameraPosition = { x: 0, y: 5, z: 10 }; // Base camera position
    let gameState = {
      ballPosition: { x: 0, y: 1.5, z: 2 },
      ballVelocity: { x: 0, y: 0, z: 0 },
      team1Score: 0,
      team2Score: 0,
      team1Games: 0,
      team2Games: 0,
      team1Sets: 0,
      team2Sets: 0,
      isPlaying: true,
      currentServer: 0, // Player ID of current server
      ballSide: 1 // 1 = team 1 side, -1 = team 2 side
    };
    
    // WebSocket variables for gesture sharing
    let ws = null;
    let wsConnected = false;
    let myPlayerId = Math.floor(Math.random() * 2); // Random player ID 0-1 for 2 players
    let connectedPlayers = {};
    
    // Daily.js variables (for video only)
    let callObject = null;
    let localParticipant = null;
    
    // Audio variables
    let audioContext;
    let backgroundMusic;
    let audioInitialized = false;
    
    // Update status function
    function updateStatus(elementId, text, className) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = text;
        element.className = 'status ' + (className || '');
      }
    }
    
    // Initialize audio context and sounds
    async function initializeAudio() {
      if (audioInitialized) return;
      
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create background music (simple procedural music)
        createBackgroundMusic();
        
        audioInitialized = true;
        console.log('‚úÖ Audio initialized');
      } catch (error) {
        console.error('Audio initialization failed:', error);
      }
    }
    
    // Create procedural background music
    function createBackgroundMusic() {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      
      oscillator.start();
      backgroundMusic = { oscillator, gainNode };
    }
    
    // Play sound effect
    function playSound(frequency, duration = 0.1, volume = 0.3) {
      if (!audioContext) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    // Join Daily.js room with iframe (for video only)
    async function joinDailyRoom() {
      try {
        const dailyContainer = document.getElementById('daily-container');
        const dailyIframe = document.getElementById('daily-iframe');
        
        // Show the Daily.js iframe
        dailyContainer.style.display = 'block';
        
        // Set the iframe source to the Daily.js room with muted mics
        dailyIframe.src = 'https://vcroom.daily.co/tennisfor4?layout=grid&showParticipantNames=true&showLeaveButton=true&startAudioOff=true';
        
        updateStatus('daily-status', 'Daily: Video Connected ‚úÖ', 'good');
        console.log('‚úÖ Joined Daily.js tennis room for video');
        
        // Initialize WebSocket for gesture data
        initializeWebSocket();
        
      } catch (error) {
        console.error('Error joining Daily room:', error);
        updateStatus('daily-status', 'Daily: Failed ‚ùå', 'error');
      }
    }
    
    // Initialize WebSocket for gesture sharing
    function initializeWebSocket() {
      try {
        // Try connecting to a local WebSocket server first
        ws = new WebSocket('ws://localhost:8082');
        
        ws.onopen = function() {
          wsConnected = true;
          updateStatus('game-status-detail', `WebSocket: Connected as Player ${myPlayerId + 1} ‚úÖ`, 'good');
          console.log('‚úÖ WebSocket connected for gesture sharing');
          
          // Send initial player join message
          ws.send(JSON.stringify({
            type: 'playerJoin',
            playerId: myPlayerId,
            timestamp: Date.now()
          }));
          
          updatePlayerCount();
        };
        
        ws.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
          } catch (error) {
            console.error('Error parsing WebSocket message:', error);
          }
        };
        
        ws.onclose = function() {
          wsConnected = false;
          updateStatus('game-status-detail', 'WebSocket: Disconnected ‚ö†Ô∏è', 'warn');
          console.log('WebSocket disconnected, falling back to local mode');
          
          // Fallback to localStorage for local testing
          initializeLocalStorage();
        };
        
        ws.onerror = function(error) {
          console.error('WebSocket error:', error);
          updateStatus('game-status-detail', 'WebSocket: Error, using local mode ‚ö†Ô∏è', 'warn');
          
          // Fallback to localStorage
          initializeLocalStorage();
        };
        
      } catch (error) {
        console.error('WebSocket initialization failed:', error);
        initializeLocalStorage();
      }
    }
    
    // Fallback to localStorage for local testing
    function initializeLocalStorage() {
      updateStatus('game-status-detail', `Local Mode: Player ${myPlayerId + 1} ‚úÖ`, 'good');
      console.log('Using localStorage for gesture sharing (local testing mode)');
      
      // Set up localStorage listener for cross-tab communication
      window.addEventListener('storage', function(e) {
        if (e.key === 'tennisGestures') {
          try {
            const data = JSON.parse(e.newValue);
            if (data.playerId !== myPlayerId) {
              handleGestureMessage(data);
            }
          } catch (error) {
            console.error('Error parsing localStorage gesture data:', error);
          }
        }
      });
      
      updatePlayerCount();
    }
    
    // Handle WebSocket messages
    function handleWebSocketMessage(data) {
      if (data.playerId === myPlayerId) return; // Ignore own messages
      
      switch (data.type) {
        case 'playerJoin':
          connectedPlayers[data.playerId] = { joinTime: data.timestamp };
          updatePlayerCount();
          break;
        case 'playerLeave':
          delete connectedPlayers[data.playerId];
          updatePlayerCount();
          break;
        case 'pose':
          handleGestureMessage(data);
          break;
        case 'ballHit':
          // Synchronize ball state
          gameState.ballVelocity = data.ballVelocity;
          tennisBall.position.copy(data.ballPosition);
          playSound(440, 0.2, 0.5);
          break;
      }
    }
    
    // Handle gesture messages
    function handleGestureMessage(data) {
      if (data.type === 'pose' && data.playerId !== myPlayerId) {
        // Apply received pose to the corresponding player
        if (data.playerId >= 0 && data.playerId < players.length && players[data.playerId]) {
          applyPoseToPlayer(data.pose, players[data.playerId]);
        }
      }
    }
    
    // Send pose data via WebSocket or localStorage
    function broadcastPoseData(pose) {
      const poseMessage = {
        type: 'pose',
        pose: pose,
        playerId: myPlayerId,
        timestamp: Date.now()
      };
      
      if (wsConnected && ws.readyState === WebSocket.OPEN) {
        // Send via WebSocket
        ws.send(JSON.stringify(poseMessage));
      } else {
        // Fallback to localStorage
        localStorage.setItem('tennisGestures', JSON.stringify(poseMessage));
      }
    }
    
    // Send ball hit data
    function broadcastBallHit() {
      const ballMessage = {
        type: 'ballHit',
        ballVelocity: gameState.ballVelocity,
        ballPosition: tennisBall.position,
        playerId: myPlayerId,
        timestamp: Date.now()
      };
      
      if (wsConnected && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(ballMessage));
      } else {
        localStorage.setItem('tennisGestures', JSON.stringify(ballMessage));
      }
    }
    
    // Update player count display
    function updatePlayerCount() {
      const connectedCount = Object.keys(connectedPlayers).length + 1; // +1 for self
      document.getElementById('player-count').textContent = connectedCount;
      
      // Update player indicators for 2 players
      const indicators = document.querySelectorAll('.player-indicator');
      indicators.forEach((indicator, index) => {
        if (index < 2) { // Only 2 players
          indicator.style.opacity = '1';
          if (index === myPlayerId) {
            indicator.classList.add('active');
          } else {
            indicator.classList.remove('active');
          }
        }
      });
    }
    
    // Initialize the tennis scene
    async function init() {
      console.log('Initializing Tennis MediaPipe scene...');
      
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      
      // Create camera - 2x zoomed Wii Sports view (FOV halved)
      camera = new THREE.PerspectiveCamera(37.5, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10); // Elevated and back for focused court view
      camera.lookAt(0, 0, 0); // Look at center of court
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x606060, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 15, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // Load 360 background first
      await load360Background();
      
      // Create tennis court
      createTennisCourt();
      
      // Create tennis ball
      createTennisBall();
      
      // Create players
      createPlayers();
      
      // Start render loop
      animate();
      
      console.log('‚úÖ Tennis MediaPipe scene initialized');
    }
    
    // Create tennis court
    function createTennisCourt() {
      // Court base
      const courtGeometry = new THREE.PlaneGeometry(23.77, 10.97);
      const courtMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x2E8B57,
        transparent: true,
        opacity: 0.8
      });
      tennisCourtMesh = new THREE.Mesh(courtGeometry, courtMaterial);
      tennisCourtMesh.rotation.x = -Math.PI / 2;
      tennisCourtMesh.receiveShadow = true;
      scene.add(tennisCourtMesh);
      
      // Court lines
      const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
      const lineHeight = 0.02;
      
      // Net
      const netGeometry = new THREE.BoxGeometry(12.8, 0.914, 0.1);
      const netMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      const net = new THREE.Mesh(netGeometry, netMaterial);
      net.position.set(0, 0.5, 0);
      net.castShadow = true;
      scene.add(net);
      
      console.log('Tennis court created');
    }
    
    // Load 360 background photosphere
    async function load360Background() {
      try {
        console.log('Loading 360 background...');
        const loader = new THREE.GLTFLoader();
        
        const gltf = await new Promise((resolve, reject) => {
          loader.load('assets/pyrenees 360 photosphere.glb', resolve, undefined, reject);
        });
        
        const photosphere = gltf.scene;
        photosphere.scale.set(50, 50, 50); // Large scale for 360 environment
        scene.add(photosphere);
        
        console.log('‚úÖ 360 background loaded');
      } catch (error) {
        console.warn('360 background failed to load, using sky color:', error);
        // Keep the sky blue background if loading fails
      }
    }
    
    // Create tennis ball - large and visible
    function createTennisBall() {
      const ballGeometry = new THREE.SphereGeometry(0.4); // 10x bigger ball
      const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
      tennisBall = new THREE.Mesh(ballGeometry, ballMaterial);
      
      // Position ball in center at good height for hitting
      tennisBall.position.set(0, 1.5, 2); // Center court, elevated
      tennisBall.castShadow = true;
      scene.add(tennisBall);
      
      console.log('Large tennis ball created in center');
    }
    
    // Create 2 players - one on each side of net
    function createPlayers() {
      const playerPositions = [
        { x: 0, z: 3 },   // Player 1 (you) - team 1 side
        { x: 0, z: -3 }   // Player 2 - team 2 side
      ];
      
      playerPositions.forEach((pos, index) => {
        const player = createPlayerCharacter(index);
        player.position.set(pos.x, 0, pos.z);
        scene.add(player);
        players.push(player);
      });
      
      console.log('2 players created - singles tennis');
    }
    
    // Create individual player character with unique appearance
    function createPlayerCharacter(playerId) {
      const characterGroup = new THREE.Group();
      
      // Player-specific colors and styles for 2 players
      const playerStyles = [
        { body: 0x4CAF50, head: 0xFFE0BD, name: 'Green Player' },   // Player 0 - Green (Team 1)
        { body: 0xFF5722, head: 0xFFDBB0, name: 'Red Player' }      // Player 1 - Red (Team 2)
      ];
      
      const style = playerStyles[playerId] || playerStyles[0];
      
      // Body with unique shape per player
      let bodyGeometry;
      switch (playerId) {
        case 0: bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5); break; // Cylinder
        case 1: bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3); break; // Box
        case 2: bodyGeometry = new THREE.ConeGeometry(0.3, 1.5, 8); break; // Cone
        case 3:
          bodyGeometry = new THREE.OctahedronGeometry(0.4);
          bodyGeometry.scale(1, 2, 1);
          break; // Octahedron
        default: bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5);
      }
      
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: style.body });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.75;
      body.castShadow = true;
      characterGroup.add(body);
      
      // Head with unique style
      let headGeometry;
      switch (playerId) {
        case 0: headGeometry = new THREE.SphereGeometry(0.25); break; // Sphere
        case 1: headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4); break; // Cube
        case 2: headGeometry = new THREE.ConeGeometry(0.2, 0.5, 6); break; // Cone
        case 3: headGeometry = new THREE.OctahedronGeometry(0.25); break; // Octahedron
        default: headGeometry = new THREE.SphereGeometry(0.25);
      }
      
      const headMaterial = new THREE.MeshLambertMaterial({ color: style.head });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.8;
      head.castShadow = true;
      characterGroup.add(head);
      
      // Player identification marker
      const markerGeometry = new THREE.RingGeometry(0.15, 0.25, 8);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: style.body,
        side: THREE.DoubleSide
      });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.y = 2.2;
      marker.rotation.x = -Math.PI / 2;
      characterGroup.add(marker);
      
      // Arms for MediaPipe control
      const rightShoulder = new THREE.Object3D();
      rightShoulder.position.set(0.4, 1.4, 0);
      rightShoulder.name = 'RightShoulder';
      characterGroup.add(rightShoulder);
      
      const rightUpperArm = new THREE.Object3D();
      rightUpperArm.position.set(0, -0.3, 0);
      rightUpperArm.name = 'RightUpperArm';
      rightShoulder.add(rightUpperArm);
      
      const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
      const armMaterial = new THREE.MeshLambertMaterial({ color: style.body });
      const rightArmMesh = new THREE.Mesh(armGeometry, armMaterial);
      rightArmMesh.position.y = -0.3;
      rightArmMesh.castShadow = true;
      rightUpperArm.add(rightArmMesh);
      
      // Left arm for balance
      const leftShoulder = new THREE.Object3D();
      leftShoulder.position.set(-0.4, 1.4, 0);
      leftShoulder.name = 'LeftShoulder';
      characterGroup.add(leftShoulder);
      
      const leftUpperArm = new THREE.Object3D();
      leftUpperArm.position.set(0, -0.3, 0);
      leftUpperArm.name = 'LeftUpperArm';
      leftShoulder.add(leftUpperArm);
      
      const leftArmMesh = new THREE.Mesh(armGeometry.clone(), armMaterial.clone());
      leftArmMesh.position.y = -0.3;
      leftArmMesh.castShadow = true;
      leftUpperArm.add(leftArmMesh);
      
      // Tennis racket
      const racketHandle = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
      const racketMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const racket = new THREE.Mesh(racketHandle, racketMaterial);
      racket.position.set(0, -0.7, 0);
      racket.castShadow = true;
      rightUpperArm.add(racket);
      
      // Store bone references for pose control
      const bones = {
        'RightShoulder': rightShoulder,
        'RightUpperArm': rightUpperArm,
        'LeftShoulder': leftShoulder,
        'LeftUpperArm': leftUpperArm,
        'rightArm': rightUpperArm,
        'leftArm': leftUpperArm,
        'racket': racket
      };
      
      characterGroup.userData = {
        bones: bones,
        playerId: playerId,
        lastSwingTime: 0,
        playerName: style.name
      };
      
      // Add name label
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = `#${style.body.toString(16).padStart(6, '0')}`;
      context.fillRect(0, 0, 256, 64);
      context.fillStyle = 'white';
      context.font = 'bold 20px Arial';
      context.textAlign = 'center';
      context.fillText(`P${playerId + 1}`, 128, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const labelGeometry = new THREE.PlaneGeometry(1, 0.25);
      const label = new THREE.Mesh(labelGeometry, labelMaterial);
      label.position.y = 2.5;
      characterGroup.add(label);
      
      return characterGroup;
    }
    
    // Set up MediaPipe pose tracking
    async function setupMediaPipe() {
      try {
        if (!window.TasksVision) {
          throw new Error('TasksVision not available');
        }
        
        const { FilesetResolver, PoseLandmarker } = window.TasksVision;
        
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1
        });
        
        updateStatus('mediapipe-status', 'MediaPipe: Ready ‚úÖ', 'good');
        console.log('‚úÖ MediaPipe pose landmarker ready');
        
      } catch (error) {
        console.error('Error setting up MediaPipe:', error);
        updateStatus('mediapipe-status', 'MediaPipe: Error ‚ùå', 'error');
      }
    }
    
    // Start camera
    async function startCamera() {
      try {
        // Initialize audio on first user interaction
        await initializeAudio();
        
        const video = document.getElementById('webcam');
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 320, height: 240 }
        });
        
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          webcamRunning = true;
          updateStatus('camera-status', 'Camera: Running ‚úÖ', 'good');
          console.log('‚úÖ Camera started');
          
          // Auto-start pose tracking
          if (!poseTrackingActive) {
            togglePoseTracking();
          }
          
          // Show join multiplayer button helper
          updateStatus('daily-status', 'Daily: Click "Join Multiplayer" ‚ñ∂Ô∏è', 'warn');
        };
        
      } catch (error) {
        console.error('Error starting camera:', error);
        updateStatus('camera-status', 'Camera: Error ‚ùå', 'error');
      }
    }
    
    // Toggle pose tracking
    function togglePoseTracking() {
      poseTrackingActive = !poseTrackingActive;
      
      if (poseTrackingActive && webcamRunning && poseLandmarker) {
        startPoseDetection();
        updateStatus('game-status-detail', 'Pose: Tracking ‚úÖ', 'good');
      } else {
        updateStatus('game-status-detail', 'Pose: Stopped ‚è∏Ô∏è', 'warn');
      }
      
      console.log('Pose tracking:', poseTrackingActive);
    }
    
    // Start pose detection loop
    function startPoseDetection() {
      const video = document.getElementById('webcam');
      
      const detectPose = async () => {
        if (!poseTrackingActive || !webcamRunning || !poseLandmarker) return;
        
        try {
          if (video.readyState >= 2) {
            const result = await poseLandmarker.detectForVideo(video, performance.now());
            
            if (result.landmarks && result.landmarks.length > 0) {
              currentPose = result.landmarks[0];
              
              // Apply pose to my player character
              if (players[myPlayerId]) {
                applyPoseToPlayer(currentPose, players[myPlayerId]);
              }
              
              // Apply head tracking for camera movement
              applyHeadTrackingToCamera(currentPose);
              
              // Broadcast pose data to other players
              broadcastPoseData(currentPose);
              
              // Update UI
              updatePoseDisplay(currentPose);
            }
          }
        } catch (error) {
          console.error('Error detecting pose:', error);
        }
        
        if (poseTrackingActive) {
          requestAnimationFrame(detectPose);
        }
      };
      
      detectPose();
    }
    
    // Apply head tracking for immersive camera movement
    function applyHeadTrackingToCamera(pose) {
      if (!pose) return;
      
      const nose = pose[0]; // Nose landmark
      const leftEye = pose[2]; // Left eye
      const rightEye = pose[5]; // Right eye
      
      if (!nose || !leftEye || !rightEye) return;
      
      // Calculate head position and rotation
      const headCenterX = (leftEye.x + rightEye.x) / 2;
      const headCenterY = (leftEye.y + rightEye.y) / 2;
      
      // Map head movement to camera movement (subtle)
      const headOffsetX = (headCenterX - 0.5) * 2; // -1 to 1 range
      const headOffsetY = (headCenterY - 0.5) * 2; // -1 to 1 range
      
      // Apply head tracking to camera base position
      baseCameraPosition.x = headOffsetX * 1.5; // Subtle left-right movement
      baseCameraPosition.y = 5 - (headOffsetY * 1); // Subtle up-down movement
      
      // Limit camera movement range
      baseCameraPosition.x = Math.max(-3, Math.min(3, baseCameraPosition.x));
      baseCameraPosition.y = Math.max(3, Math.min(7, baseCameraPosition.y));
    }
    
    // Apply MediaPipe pose to player character
    function applyPoseToPlayer(pose, player) {
      if (!pose || !player) return;
      
      const wrist = pose[16]; // Right wrist
      const elbow = pose[14]; // Right elbow
      const shoulder = pose[12]; // Right shoulder
      const leftWrist = pose[15]; // Left wrist
      const leftElbow = pose[13]; // Left elbow
      const leftShoulder = pose[11]; // Left shoulder
      
      if (!wrist || !elbow || !shoulder) return;
      
      const bones = player.userData.bones;
      if (!bones) return;
      
      // Calculate swing motion
      const swingVelocity = Math.sqrt(
        Math.pow(wrist.x - shoulder.x, 2) +
        Math.pow(wrist.y - shoulder.y, 2)
      );
      
      // Apply right arm rotation
      if (bones.rightArm) {
        const armAngleX = (wrist.y - shoulder.y) * 3;
        const armAngleZ = -(wrist.x - shoulder.x) * 3; // Reverse Z for proper arm direction
        
        bones.rightArm.rotation.x = armAngleX;
        bones.rightArm.rotation.z = armAngleZ;
      }
      
      // Apply left arm rotation for more realistic movement
      if (bones.leftArm && leftWrist && leftElbow && leftShoulder) {
        const leftArmAngleX = (leftWrist.y - leftShoulder.y) * 3;
        const leftArmAngleZ = -(leftWrist.x - leftShoulder.x) * 3; // Reverse Z for proper arm direction
        
        bones.leftArm.rotation.x = leftArmAngleX;
        bones.leftArm.rotation.z = leftArmAngleZ;
      }
      
      // Only trigger ball hits for the local player (not remote pose data)
      if (player.userData.playerId === myPlayerId && swingVelocity > 0.3 && Date.now() - player.userData.lastSwingTime > 800) {
        console.log(`üéæ ${player.userData.playerName} swing detected!`, { velocity: swingVelocity });
        player.userData.lastSwingTime = Date.now();
        
        // Play swing sound
        playSound(200, 0.1, 0.3);
        
        // Trigger ball hit if ball is nearby
        hitBallIfNearby(player, swingVelocity);
      }
    }
    
    // Ultra-simplified tennis: wave arm to send ball to other side
    function hitBallIfNearby(player, swingPower) {
      // Simplified: any swing motion sends ball to opposite side
      const playerId = player.userData.playerId;
      
      // Determine target side based on current ball position
      let targetZ;
      if (gameState.ballSide === 1) {
        // Ball on player 1 side, send to player 2 side
        targetZ = -3;
        gameState.ballSide = -1;
      } else {
        // Ball on player 2 side, send to player 1 side
        targetZ = 3;
        gameState.ballSide = 1;
      }
      
      // Parabolic ball trajectory with higher arc
      const distance = Math.abs(targetZ - tennisBall.position.z);
      gameState.ballVelocity.x = (Math.random() - 0.5) * 1; // Slight random x movement
      gameState.ballVelocity.y = 4 + (distance * 0.5); // Higher parabolic arc
      gameState.ballVelocity.z = (targetZ - tennisBall.position.z) * 1.5; // Toward target
      
      console.log(`üéæ Player ${playerId + 1} hit ball to Player ${gameState.ballSide === 1 ? '1' : '2'} side!`);
      
      // Play ball hit sound
      playSound(440, 0.2, 0.5);
      
      // Broadcast ball hit to other players
      broadcastBallHit();
    }
    
    // Update pose display
    function updatePoseDisplay(pose) {
      const wrist = pose[16];
      const velocity = wrist ? Math.sqrt(wrist.x * wrist.x + wrist.y * wrist.y) : 0;
      
      document.getElementById('swing-velocity').textContent = velocity.toFixed(3);
      document.getElementById('ball-position').textContent = 
        `${tennisBall.position.x.toFixed(1)}, ${tennisBall.position.y.toFixed(1)}, ${tennisBall.position.z.toFixed(1)}`;
    }
    
    // Update ball physics
    function updateBallPhysics() {
      const dt = 0.016; // 60fps
      
      // Apply gravity
      gameState.ballVelocity.y -= 9.8 * dt;
      
      // Update position
      tennisBall.position.x += gameState.ballVelocity.x * dt;
      tennisBall.position.y += gameState.ballVelocity.y * dt;
      tennisBall.position.z += gameState.ballVelocity.z * dt;
      
      // Ground bounce - higher for large ball
      if (tennisBall.position.y <= 0.4) {
        tennisBall.position.y = 0.4;
        gameState.ballVelocity.y = Math.abs(gameState.ballVelocity.y) * 0.6;
        gameState.ballVelocity.x *= 0.9;
        gameState.ballVelocity.z *= 0.9;
        
        // Play bounce sound
        playSound(330, 0.1, 0.2);
        
        // Check if ball missed (went too far on either side)
        if (Math.abs(tennisBall.position.z) > 4.5) {
          console.log('üéæ Ball out of bounds! Scoring...');
          handleBallMiss();
          return;
        }
      }
      
      // Court bounds - score points if ball goes out
      if (Math.abs(tennisBall.position.x) > 8) {
        console.log('üéæ Ball out of bounds sideline!');
        handleBallMiss();
        return;
      }
      
      if (Math.abs(tennisBall.position.z) > 5.5) {
        console.log('üéæ Ball out of bounds baseline!');
        handleBallMiss();
        return;
      }
      
      // Reset ball if it goes too high
      if (tennisBall.position.y > 20) {
        resetBallToCenter();
      }
    }
    
    // Handle ball miss and scoring with better logic
    function handleBallMiss() {
      console.log('üéæ Ball missed! Scoring point...');
      
      // Determine which player gets the point based on ball position
      let scoringPlayer;
      if (tennisBall.position.z > 0) {
        // Ball went out on player 1's side, so player 2 scores
        scoringPlayer = 2;
        gameState.team2Score++;
      } else {
        // Ball went out on player 2's side, so player 1 scores
        scoringPlayer = 1;
        gameState.team1Score++;
      }
      
      console.log(`üèÜ Player ${scoringPlayer} scores! New score: ${gameState.team1Score}-${gameState.team2Score}`);
      updateScore();
      
      // Add delay before resetting ball
      setTimeout(() => {
        resetBallToCenter();
      }, 1000);
    }
    
    // Update tennis scoring display
    function updateScore() {
      const scoreNames = ['0', '15', '30', '40'];
      
      // Convert numeric scores to tennis scores
      const team1Display = gameState.team1Score < 4 ? scoreNames[gameState.team1Score] : 'GAME';
      const team2Display = gameState.team2Score < 4 ? scoreNames[gameState.team2Score] : 'GAME';
      
      document.getElementById('team1-score').textContent = team1Display;
      document.getElementById('team2-score').textContent = team2Display;
      
      // Check for game win (first to 4 points with 2-point lead)
      if (gameState.team1Score >= 4 && gameState.team1Score - gameState.team2Score >= 2) {
        gameWon(1);
      } else if (gameState.team2Score >= 4 && gameState.team2Score - gameState.team1Score >= 2) {
        gameWon(2);
      }
      
      // Update game status for 2 players
      if (gameState.team1Sets >= 2) {
        document.getElementById('game-status').textContent = 'Player 1 Wins Match!';
      } else if (gameState.team2Sets >= 2) {
        document.getElementById('game-status').textContent = 'Player 2 Wins Match!';
      } else {
        document.getElementById('game-status').textContent =
          `Set ${gameState.team1Sets + gameState.team2Sets + 1} - Games: ${gameState.team1Games}-${gameState.team2Games}`;
      }
    }
    
    // Handle game win
    function gameWon(team) {
      console.log(`üèÜ Player ${team} wins the game!`);
      
      if (team === 1) {
        gameState.team1Games++;
      } else {
        gameState.team2Games++;
      }
      
      // Reset point scores
      gameState.team1Score = 0;
      gameState.team2Score = 0;
      
      // Check for set win (first to 2 games)
      if (gameState.team1Games >= 2) {
        setWon(1);
      } else if (gameState.team2Games >= 2) {
        setWon(2);
      }
    }
    
    // Handle set win
    function setWon(team) {
      console.log(`üèÜ Player ${team} wins the set!`);
      
      if (team === 1) {
        gameState.team1Sets++;
      } else {
        gameState.team2Sets++;
      }
      
      // Reset game scores
      gameState.team1Games = 0;
      gameState.team2Games = 0;
      
      // Check for match win (best of 3 sets)
      if (gameState.team1Sets >= 2 || gameState.team2Sets >= 2) {
        console.log(`üèÜ Match complete! Player ${team} wins!`);
        gameState.isPlaying = false;
      }
    }
    
    // Reset ball to center position
    function resetBallToCenter() {
      tennisBall.position.set(0, 1.5, 0); // Center court, elevated
      gameState.ballVelocity = { x: 0, y: 0, z: 0 };
      gameState.ballSide = Math.random() > 0.5 ? 1 : -1; // Random starting side
    }
    
    // Reset ball position (legacy function)
    function resetBall() {
      resetBallToCenter();
    }
    
    // Reset game
    function resetGame() {
      resetBallToCenter();
      gameState.team1Score = 0;
      gameState.team2Score = 0;
      gameState.team1Games = 0;
      gameState.team2Games = 0;
      gameState.team1Sets = 0;
      gameState.team2Sets = 0;
      gameState.isPlaying = true;
      
      document.getElementById('team1-score').textContent = '0';
      document.getElementById('team2-score').textContent = '0';
      document.getElementById('game-status').textContent = 'New Match Started';
    }
    
    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Update ball physics
      updateBallPhysics();
      
      // Cinematic camera movement with gentle squirrel motion
      cameraTime += 0.01;
      
      // Gentle camera movement around base position
      const cameraOffset = {
        x: Math.sin(cameraTime * 0.3) * 0.5, // Gentle side-to-side
        y: Math.sin(cameraTime * 0.2) * 0.2, // Subtle up-down
        z: Math.cos(cameraTime * 0.1) * 0.3  // Forward-back motion
      };
      
      camera.position.set(
        baseCameraPosition.x + cameraOffset.x,
        baseCameraPosition.y + cameraOffset.y,
        baseCameraPosition.z + cameraOffset.z
      );
      
      // Look at center with slight movement
      const lookAtOffset = {
        x: Math.sin(cameraTime * 0.4) * 0.2,
        y: 0,
        z: Math.cos(cameraTime * 0.3) * 0.1
      };
      
      camera.lookAt(lookAtOffset.x, lookAtOffset.y, lookAtOffset.z);
      
      // Render
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize everything
    init();
    
    // Auto-setup everything when script loads
    setTimeout(async () => {
      console.log('üöÄ Auto-starting tennis experience...');
      
      // Setup MediaPipe first
      await setupMediaPipe();
      
      // Auto-enable all features for seamless experience
      setTimeout(() => {
        console.log('üöÄ Auto-joining multiplayer...');
        joinDailyRoom();
      }, 2000);
      
      setTimeout(() => {
        console.log('üöÄ Auto-starting camera and pose tracking...');
        startCamera();
      }, 3000);
      
    }, 1000);
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      if (ws && wsConnected) {
        ws.send(JSON.stringify({
          type: 'playerLeave',
          playerId: myPlayerId,
          timestamp: Date.now()
        }));
        ws.close();
      }
      if (callObject) {
        callObject.leave();
        callObject.destroy();
      }
      if (backgroundMusic && backgroundMusic.oscillator) {
        backgroundMusic.oscillator.stop();
      }
    });
  </script>
</body>
</html>